= Your Java EE app on Kubernetes
// See https://hubpress.gitbooks.io/hubpress-knowledgebase/content/ for information about the parameters.
// :hp-image: /covers/cover.png
// :published_at: 2019-01-31
// :hp-tags: HubPress, Blog, Open_Source,
// :hp-alt-title: My English Title

In https://pdudits.github.io/2017/05/23/Running-Payara-in-Kubernetes.html[previous  post] we managed to run Payara on Kubernetes. 
This is if course bit dull without applicatinos deployed. 
Let's see what we will need to have our app in Kubernetes as well:

* .war Maven project
* Fabric8 Maven plugin
* Docker for Windows / Docker tools

== Installing Docker tooling

Given my hobby environment (Windows 10 Home), I cannot use the current Docker for Windows installation (remember, no HyperV in home edition). 
Therefore I need to install https://www.docker.com/products/docker-toolbox[Docker Toolbox], its retired ancestor.

== Sidecar approach
I assume you don't upgrade your application server as often as you upgrade your applications. 
But when you do upgrade your server, you shouldn't need to rebuild all of your applications. At least I wouldn't like to do that.

Kubernetes gives you solution to that, called https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/#understanding-pods[Sidecar containers].
Instead of running single image, you put multiple images together, and they can speak to each other via local host, or share directories.

So we will take http://blog.payara.fish/payara-docker-images-162-release-update[Official Payara Docker Image], mount its autodeploy directory, and for our app we will build an image based on busybox, that will just copy our .war file to that folder.

image::/images/Kubernetes%20sidecar.png[]

The app-sidecar will be based on busybox, adding just 1MB of binaries to our app package.

== Creating Docker images with Maven

One doesn't leave its trusted tools for these fancy new tech!
Everything you need to do concerning Docker images and Kubernetes you can achieve with https://maven.fabric8.io/[Fabric8 Maven Plugin].
Fabric8 is entire deployment platform for Kubernetes, and I will surely look into it in next posts -- first, I need to understand what am I doing before I let magical tools do that for me ;).

The goal `build` of Fabric8 plugin constructs the Docker image based on https://maven.fabric8.io/#image-configuration[image configuration].
So this is what the interesting parts of https://github.com/pdudits/k8se9s/blob/master/payara-sidecar/pom.xml[`pom.xml`] look like:

[source,xml]
----
include::https://raw.githubusercontent.com/pdudits/k8se9s/master/payara-sidecar/pom.xml[tags=fabric8,indent=0]
----
<1> The name of docker image. `%a` stands for artifactId, `%l` stands for release verson or `latest` for snapshot
<2> we can use this alias for defining kuberenetes resources later
<3> Our base image
<4> The https://maven.apache.org/plugins/maven-assembly-plugin/descriptor-refs.html[Maven Assembly Descriptor Name], describing what should be copied into the image (inside directory `/maven` by default)

To actually run the build you need to have Docker environment configured, as the plugin will call out to Docker.
Minikube has this nice feature, that it will https://kubernetes.io/docs/getting-started-guides/minikube/#reusing-the-docker-daemon[reuse Docker daemon] from within minikube VM.
You therefore doesn't need to run another VM, just make sure to `minikube start` before invoking maven.
That also means, that whatever you build is immediately available for deployment into your Kubernetes cluster.

== Creating Kubernetes Resource Descriptors with Maven

`fabric8:resource` will take YAML files that serve as templates for resource descriptors, add some useful annotations to them, and attaches them as build results.

For our sidecar we will create a https://kubernetes.io/docs/concepts/workloads/controllers/deployment/[Deployment].
It is a declaration of what Pod should look like with added features like replication -- deployment more of same pod -- and rolling upgrade. Especially the rolling upgrade is interesting for us. When you upgrade your app, a new Pod will be created, and when it starts successfully, the trafic will be directed to it, and after that the old pod is stopped.

So let's see the file:

[source,yaml]
----
include::https://raw.githubusercontent.com/pdudits/k8se9s/master/payara-sidecar/src/main/fabric8/payara-deployment.yaml[]
----
<1> That's the directory shared between Docker images
<2> We refer to the image via alias from `pom.xml`
<3> The shared volume is accessible via /apps for container app-sidecar
<4> We copy the files. Every container need to have running process, otherwise it is marked as crashed. Therefore we just hang, waiting for input from the void.
<5> Payara is the other container in the pod
<6> Yes that's the old version, you'll soon find out why...
<7> And the files we copied into /apps Payara sees in its autodeploy directory.


